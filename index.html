<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dr. Deas Luxury Mansion Library</title>

    <meta property="og:title" content="Dr. Deas Luxury Mansion Library">
    <meta property="og:description" content="Experience Dr. Deas's reading collection in an immersive luxury mansion environment — optimized for VR headset.">
    <meta property="og:image" content="https://drdeas.github.io/DrDeasVirtualLibrary/341_books_collage.png">
    <meta property="og:url" content="https://drdeas.github.io/DrDeasVirtualLibrary/index.html">
    <meta property="og:type" content="website">
    
    <style>
        :root {
            --primary-dark: #1a1a2e;
            --secondary-dark: #2a2a3e;
            --primary-brown: #8b7355;
            --primary-brown-hover: #6d5a43;
            --accent-gold: #d4af37;
            --text-light: #f0f0f0;
            --text-muted: #c0c0c0;
            --disabled-bg: #666;
            --font-main: 'Georgia', serif;
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: var(--primary-dark);
            font-family: var(--font-main);
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: var(--text-light);
            background: rgba(26, 26, 46, 0.9);
            padding: 15px;
            border-radius: 8px;
            z-index: 100;
            border: 2px solid var(--primary-brown);
            max-width: 300px;
        }

        #info h3 {
            margin: 0 0 10px 0;
            color: var(--accent-gold);
            font-size: 18px;
        }

        #info p {
            margin: 5px 0;
            font-size: 14px;
        }

        #info p:nth-child(n+4):nth-child(-n+6) {
            padding-left: 20px;
        }
        
        #vrButton {
            position: absolute;
            bottom: 20px;
            right: 20px;
            padding: 12px 24px;
            background: var(--primary-brown);
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            cursor: pointer;
            z-index: 100;
            transition: background 0.3s;
        }

        #vrButton:hover {
            background: var(--primary-brown-hover);
        }

        #vrButton:disabled {
            background: var(--disabled-bg);
            cursor: not-allowed;
        }

        #navigationTool {
            position: absolute;
            bottom: 80px;
            right: 20px;
            z-index: 100;
            background: rgba(26, 26, 46, 0.9);
            border: 2px solid var(--primary-brown);
            border-radius: 8px;
            padding: 10px;
            display: grid;
            grid-template-columns: repeat(3, 50px);
            grid-template-rows: repeat(3, 50px);
            gap: 5px;
        }

        .nav-btn {
            width: 50px;
            height: 50px;
            background: var(--primary-brown);
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
        }

        .nav-btn:hover {
            background: var(--primary-brown-hover);
        }

        .nav-btn:active {
            background: #4a3829;
            transform: scale(0.95);
        }

        .nav-btn:disabled {
            background: var(--disabled-bg);
            cursor: not-allowed;
        }

        #navUp { grid-column: 2; grid-row: 1; }
        #navDown { grid-column: 2; grid-row: 3; }
        #navLeft { grid-column: 1; grid-row: 2; }
        #navRight { grid-column: 3; grid-row: 2; }
        #navForward { grid-column: 1; grid-row: 3; font-size: 10px; }
        #navBackward { grid-column: 3; grid-row: 3; font-size: 10px; }
        #navRotateLeft { grid-column: 1; grid-row: 1; font-size: 10px; }
        #navRotateRight { grid-column: 3; grid-row: 1; font-size: 10px; }
        
        canvas {
            display: block;
            cursor: pointer;
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
        }

        .modal-content {
            background-color: var(--secondary-dark);
            margin: 5% auto;
            padding: 20px;
            border: 2px solid var(--primary-brown);
            border-radius: 10px;
            width: 80%;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            color: var(--text-light);
        }

        .close {
            color: var(--accent-gold);
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
        }

        .close:hover {
            color: #fff;
        }

        #bookDetails {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }

        #modalBookCover {
            width: 200px;
            height: auto;
            border-radius: 5px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            flex-shrink: 0;
        }

        #modalBookInfo {
            flex: 1;
        }

        #modalBookInfo h2 {
            color: var(--accent-gold);
            margin: 0 0 10px 0;
            font-size: 24px;
        }

        #modalBookInfo h3 {
            color: var(--text-muted);
            margin: 0 0 15px 0;
            font-style: italic;
        }

        #modalBookInfo p {
            margin: 8px 0;
            line-height: 1.4;
        }

        #modalSummary {
            margin-top: 15px;
            line-height: 1.6;
            text-align: justify;
        }

        @media (max-width: 600px) {
            #bookDetails {
                flex-direction: column;
                align-items: center;
            }
            
            #modalBookCover {
                width: 150px;
            }
            
            .modal-content {
                width: 95%;
                margin: 2% auto;
                max-width: none;
                padding: 15px;
                box-sizing: border-box;
            }

            #navigationTool {
                bottom: 60px;
                right: 10px;
                padding: 8px;
                grid-template-columns: repeat(3, 40px);
                grid-template-rows: repeat(3, 40px);
                gap: 4px;
            }

            .nav-btn {
                width: 40px;
                height: 40px;
                font-size: 10px;
            }
        }
    </style>
</head>
<body>
    <div id="info">
        <h3>Dr. Deas Luxury Mansion Library</h3>
        <p>Click "Enter VR" in any supported VR headset</p>
        <p>Desktop: Use arrow keys (↑↓←→) to explore</p>
        <p>● W/S keys: Move vertically up/down</p>
        <p>● A/D keys: Rotate left/right</p>
        <p>● R key: Reset view</p>
        <p>Books loaded: <span id="bookCount" style="color: var(--accent-gold); font-weight: bold;">0</span> (Click books to view details)</p>
    </div>
    <button id="vrButton">Enter VR</button>

    <div id="navigationTool">
        <button class="nav-btn" id="navRotateLeft" aria-label="Rotate Left">↺ L</button>
        <button class="nav-btn" id="navUp" aria-label="Move Up">▲</button>
        <button class="nav-btn" id="navRotateRight" aria-label="Rotate Right">↻ R</button>
        <button class="nav-btn" id="navLeft" aria-label="Move Left">◄</button>
        <button class="nav-btn" id="navForward" aria-label="Move Forward">FWD</button>
        <button class="nav-btn" id="navRight" aria-label="Move Right">►</button>
        <button class="nav-btn" id="navBackward" aria-label="Move Backward">BWD</button>
        <button class="nav-btn" id="navDown" aria-label="Move Down">▼</button>
    </div>

    <div id="bookModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <div id="bookDetails">
                <img id="modalBookCover" src="" alt="Book Cover">
                <div id="modalBookInfo">
                    <h2 id="modalTitle"></h2>
                    <h3 id="modalAuthor"></h3>
                    <p><strong>Category:</strong> <span id="modalCategory"></span></p>
                    <p><strong>Status:</strong> <span id="modalStatus"></span></p>
                    <p><strong>Ownership:</strong> <span id="modalOwnership"></span></p>
                    <p><strong>Date Completed:</strong> <span id="modalDate"></span></p>
                    <div id="modalSummary"></div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // =============================================================================
        // DATA (First 3 books only)
        // =============================================================================
        const books = [
            {
                "number": 1,
                "title": "Begin Again: James Baldwin's America and Its Urgent Lessons for Our Own",
                "author": "Eddie S. Glaude, Jr.",
                "category": "Biography",
                "ownership": "Digital",
                "status": "Finished",
                "dateCompleted": "2020-10-03",
                "customCoverUrl": "https://raw.githubusercontent.com/DrDeas/DrDeasBookLog/refs/heads/main/images/Book_00001.jpg",
                "id": 1,
                "summary": "This book offers a powerful examination of American history and identity through the lens of James Baldwin's work."
            },
            {
                "number": 2,
                "title": "David and Goliath: Underdogs, Misfits, and the Art of Battling Giants",
                "author": "Malcolm Gladwell",
                "category": "Social Science(s)",
                "ownership": "Physical",
                "status": "Finished",
                "dateCompleted": "2020-10-08",
                "customCoverUrl": "https://raw.githubusercontent.com/DrDeas/DrDeasBookLog/refs/heads/main/images/Book_00002.jpg",
                "id": 2,
                "summary": "This book explores the dynamics of encounters between the powerful and the seemingly weak."
            },
            {
                "number": 3,
                "title": "Talking to Strangers: What We Should Know about the People We Don't Know",
                "author": "Malcolm Gladwell",
                "category": "Social Science(s)",
                "ownership": "Digital",
                "status": "Finished",
                "dateCompleted": "2020-10-13",
                "customCoverUrl": "https://raw.githubusercontent.com/DrDeas/DrDeasBookLog/refs/heads/main/images/Book_00003.jpg",
                "id": 3,
                "summary": "This book explores the misunderstandings that arise when people interact with strangers."
            }
        ];

        // =============================================================================
        // CONFIGURATION & CONSTANTS
        // =============================================================================
        const LIBRARY_WIDTH = 60;
        const LIBRARY_DEPTH = 60;
        const LIBRARY_HEIGHT = 12;
        const BOOKS_PER_SHELF = 8;
        const SHELVES_PER_BOOKCASE = 5;
        const BOOKS_PER_BOOKCASE = BOOKS_PER_SHELF * SHELVES_PER_BOOKCASE;
        const BOOKCASE_WIDTH = 10;
        const BOOKCASE_HEIGHT = 8.2;
        const BOOKCASE_SPACING = 2;
        const SHELF_THICKNESS = 0.2;
        const SHELF_DEPTH = 1.5;
        const SHELF_SPACING_Y = 1.6;
        const SHELF_BASE_Y = 1.0;
        const SUPPORT_WIDTH = 0.3;
        const BOOK_WIDTH = 0.8;
        const BOOK_HEIGHT = 1.2;
        const BOOK_THICKNESS = 0.2;
        const BOOK_SPACING_X = 1.0;

        // =============================================================================
        // GLOBAL VARIABLES
        // =============================================================================
        let scene, camera, renderer, vrButton;
        let isVREnabled = false;
        let inputController, playerController;

        const bookMeshes = [];
        const collisionMeshes = [];
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let modal, closeBtn;
        const clock = new THREE.Clock();

        // =============================================================================
        // INPUT CONTROLLER CLASS
        // =============================================================================
        class InputController {
            constructor() {
                this.keys = new Set();
                this.buttonActions = {
                    moveForward: 0,
                    moveStrafe: 0,
                    moveVertical: 0,
                    lookHorizontal: 0
                };
                this.actions = {
                    moveForward: 0,
                    moveStrafe: 0,
                    moveVertical: 0,
                    lookHorizontal: 0,
                    reset: false
                };
            }

            connect() {
                document.addEventListener('keydown', (e) => this.onKeyChange(e, true));
                document.addEventListener('keyup', (e) => this.onKeyChange(e, false));
                window.addEventListener('blur', () => this.keys.clear());
            }

            onKeyChange(event, isPressed) {
                if (isPressed) {
                    this.keys.add(event.code);
                } else {
                    this.keys.delete(event.code);
                }

                if (event.code === 'KeyR' && isPressed) {
                    this.actions.reset = true;
                }
            }

            setButtonAction(action, value) {
                if (this.buttonActions.hasOwnProperty(action)) {
                    this.buttonActions[action] = value;
                }
            }
            
            update() {
                const arrowFwd = this.keys.has('ArrowUp');
                const arrowBwd = this.keys.has('ArrowDown');
                const arrowLeft = this.keys.has('ArrowLeft');
                const arrowRight = this.keys.has('ArrowRight');
                
                const wKey = this.keys.has('KeyW');
                const sKey = this.keys.has('KeyS');
                const aKey = this.keys.has('KeyA');
                const dKey = this.keys.has('KeyD');

                this.actions.moveForward = (Number(arrowBwd) - Number(arrowFwd)) + this.buttonActions.moveForward;
                this.actions.moveStrafe = (Number(arrowRight) - Number(arrowLeft)) + this.buttonActions.moveStrafe;
                this.actions.moveVertical = (Number(wKey) - Number(sKey)) + this.buttonActions.moveVertical;
                this.actions.lookHorizontal = (Number(dKey) - Number(aKey)) + this.buttonActions.lookHorizontal;

                this.actions.moveForward = Math.max(-1, Math.min(1, this.actions.moveForward));
                this.actions.moveStrafe = Math.max(-1, Math.min(1, this.actions.moveStrafe));
                this.actions.moveVertical = Math.max(-1, Math.min(1, this.actions.moveVertical));
                this.actions.lookHorizontal = Math.max(-1, Math.min(1, this.actions.lookHorizontal));
            }
        }

        // =============================================================================
        // PLAYER CONTROLLER CLASS
        // =============================================================================
        class PlayerController {
            constructor(camera, domElement) {
                this.camera = camera;
                this.domElement = domElement;
                this.linearVelocity = new THREE.Vector3();
                this.angularVelocity = new THREE.Vector3();
                this.acceleration = 40.0;
                this.rotationSpeed = 3.5;
                this.friction = 10.0;
                this.connect();
            }
            
            resetView() {
                this.camera.position.copy(this.camera.userData.initialPosition);
                this.camera.rotation.copy(this.camera.userData.initialRotation);
                this.linearVelocity.set(0, 0, 0);
                this.angularVelocity.set(0, 0, 0);
            }

            connect() {
                let isDragging = false;
                this.domElement.addEventListener('mousedown', () => { isDragging = true; });
                window.addEventListener('mouseup', () => { isDragging = false; });
                window.addEventListener('mousemove', (event) => {
                    if (isDragging) {
                        this.onMouseMove(event);
                    }
                });
            }

            onMouseMove = (event) => {
                this.camera.rotation.y -= event.movementX * 0.002;
                this.camera.rotation.x -= event.movementY * 0.002;
                this.camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.camera.rotation.x));
            }

            checkCollisions(newPosition) {
                const collisionDistance = 1.5;
                
                for (let collisionMesh of collisionMeshes) {
                    const distance = newPosition.distanceTo(collisionMesh.position);
                    if (distance < collisionDistance) {
                        return true;
                    }
                }
                
                if (newPosition.x < -LIBRARY_WIDTH / 2 + 2 || newPosition.x > LIBRARY_WIDTH / 2 - 2 ||
                    newPosition.z < -LIBRARY_DEPTH / 2 + 2 || newPosition.z > LIBRARY_DEPTH / 2 - 2) {
                    return true;
                }
                
                return false;
            }

            update(delta, actions) {
                this.linearVelocity.x -= this.linearVelocity.x * this.friction * delta;
                this.linearVelocity.z -= this.linearVelocity.z * this.friction * delta;
                this.linearVelocity.y -= this.linearVelocity.y * this.friction * delta;
                this.angularVelocity.y -= this.angularVelocity.y * this.friction * delta;

                const direction = new THREE.Vector3(actions.moveStrafe, actions.moveVertical, actions.moveForward);
                direction.normalize();

                if (direction.length() > 0) {
                   this.linearVelocity.x += direction.x * this.acceleration * delta;
                   this.linearVelocity.z += direction.z * this.acceleration * delta;
                   this.linearVelocity.y += direction.y * this.acceleration * delta;
                }

                if (actions.lookHorizontal !== 0) {
                    this.angularVelocity.y += actions.lookHorizontal * this.rotationSpeed * delta;
                }

                const newPosition = this.camera.position.clone();
                newPosition.x += this.linearVelocity.x * delta;
                newPosition.z += this.linearVelocity.z * delta;
                
                const testPosX = this.camera.position.clone();
                testPosX.x = newPosition.x;
                if (!this.checkCollisions(testPosX)) {
                    this.camera.position.x = newPosition.x;
                }
                
                const testPosZ = this.camera.position.clone();
                testPosZ.z = newPosition.z;
                if (!this.checkCollisions(testPosZ)) {
                    this.camera.position.z = newPosition.z;
                }

                this.camera.position.y += this.linearVelocity.y * delta;
                this.camera.rotation.y -= this.angularVelocity.y * delta;
                
                this.camera.position.y = Math.max(0.8, Math.min(10.0, this.camera.position.y));
            }
        }

        // =============================================================================
        // UTILITY FUNCTIONS
        // =============================================================================
        function createMarbleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            gradient.addColorStop(0, '#f8f8ff');
            gradient.addColorStop(0.3, '#e6e6fa');
            gradient.addColorStop(0.7, '#dcdcdc');
            gradient.addColorStop(1, '#f0f8ff');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.strokeStyle = 'rgba(169, 169, 169, 0.3)';
            ctx.lineWidth = 2;
            for (let i = 0; i < 20; i++) {
                ctx.beginPath();
                ctx.moveTo(Math.random() * canvas.width, Math.random() * canvas.height);
                ctx.quadraticCurveTo(
                    Math.random() * canvas.width, Math.random() * canvas.height,
                    Math.random() * canvas.width, Math.random() * canvas.height
                );
                ctx.stroke();
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(4, 4);
            return texture;
        }

        function createColumn(x, y, z, material) {
            const columnGroup = new THREE.Group();
            
            const shaftGeometry = new THREE.CylinderGeometry(0.8, 0.8, LIBRARY_HEIGHT - 2, 16);
            const shaft = new THREE.Mesh(shaftGeometry, material);
            shaft.position.y = y - 1;
            shaft.castShadow = true;
            columnGroup.add(shaft);

            const baseGeometry = new THREE.CylinderGeometry(1.2, 1.2, 1, 16);
            const base = new THREE.Mesh(baseGeometry, material);
            base.position.y = 0.5;
            base.castShadow = true;
            columnGroup.add(base);

            const capitalGeometry = new THREE.CylinderGeometry(1.2, 0.8, 1, 16);
            const capital = new THREE.Mesh(capitalGeometry, material);
            capital.position.y = LIBRARY_HEIGHT - 1.5;
            capital.castShadow = true;
            columnGroup.add(capital);

            columnGroup.position.set(x, 0, z);
            return columnGroup;
        }

        // =============================================================================
        // SCENE CREATION FUNCTIONS
        // =============================================================================
        function createLighting() {
            const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x443322, 0.4);
            scene.add(hemisphereLight);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight.position.set(20, 30, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 4096;
            directionalLight.shadow.mapSize.height = 4096;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 100;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            scene.add(directionalLight);

            const warmLight = new THREE.PointLight(0xffd700, 0.8, 30);
            warmLight.position.set(0, 8, 0);
            warmLight.castShadow = true;
            scene.add(warmLight);
        }

        function createMansionEnvironment() {
            // Elegant marble floor
            const floorGeometry = new THREE.PlaneGeometry(LIBRARY_WIDTH, LIBRARY_DEPTH, 20, 20);
            const marbleTexture = createMarbleTexture();
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                map: marbleTexture,
                roughness: 0.1,
                metalness: 0.1
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // Grass areas
            createGrassAreas();
            // Mansion walls
            createMansionWalls();
            // Ornate ceiling
            createOrnateCompartmentCeiling();
        }

        function createGrassAreas() {
            const grassMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
            
            const grassPatches = [
                { pos: [-35, 0, -35], size: [15, 15] },
                { pos: [35, 0, -35], size: [15, 15] },
                { pos: [-35, 0, 35], size: [15, 15] },
                { pos: [35, 0, 35], size: [15, 15] },
                { pos: [0, 0, 40], size: [25, 10] },
                { pos: [0, 0, -40], size: [25, 10] }
            ];

            grassPatches.forEach(patch => {
                const grassGeometry = new THREE.PlaneGeometry(patch.size[0], patch.size[1]);
                const grass = new THREE.Mesh(grassGeometry, grassMaterial);
                grass.rotation.x = -Math.PI / 2;
                grass.position.set(patch.pos[0], patch.pos[1], patch.pos[2]);
                grass.receiveShadow = true;
                scene.add(grass);
            });
        }

        function createMansionWalls() {
            const wallMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xf5f5dc,
                roughness: 0.3,
                metalness: 0.1
            });

            const columnMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffffff,
                roughness: 0.2,
                metalness: 0.1
            });

            // Walls
            const backWall = new THREE.Mesh(new THREE.PlaneGeometry(LIBRARY_WIDTH, LIBRARY_HEIGHT), wallMaterial);
            backWall.position.set(0, LIBRARY_HEIGHT / 2, -LIBRARY_DEPTH / 2);
            backWall.receiveShadow = true;
            scene.add(backWall);

            // Add columns
            for (let i = -2; i <= 2; i++) {
                const column = createColumn(i * 12, LIBRARY_HEIGHT / 2, -LIBRARY_DEPTH / 2 + 1, columnMaterial);
                scene.add(column);
                collisionMeshes.push(column);
            }

            const leftWall = new THREE.Mesh(new THREE.PlaneGeometry(LIBRARY_DEPTH, LIBRARY_HEIGHT), wallMaterial);
            leftWall.position.set(-LIBRARY_WIDTH / 2, LIBRARY_HEIGHT / 2, 0);
            leftWall.rotation.y = Math.PI / 2;
            leftWall.receiveShadow = true;
            scene.add(leftWall);

            const rightWall = new THREE.Mesh(new THREE.PlaneGeometry(LIBRARY_DEPTH, LIBRARY_HEIGHT), wallMaterial);
            rightWall.position.set(LIBRARY_WIDTH / 2, LIBRARY_HEIGHT / 2, 0);
            rightWall.rotation.y = -Math.PI / 2;
            rightWall.receiveShadow = true;
            scene.add(rightWall);
        }

        function createOrnateCompartmentCeiling() {
            const ceilingMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xfaf0e6,
                roughness: 0.4,
                metalness: 0.1
            });

            const ceilingGeometry = new THREE.PlaneGeometry(LIBRARY_WIDTH, LIBRARY_DEPTH);
            const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
            ceiling.rotation.x = Math.PI / 2;
            ceiling.position.y = LIBRARY_HEIGHT;
            scene.add(ceiling);

            const beamMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
            
            for (let i = -2; i <= 2; i++) {
                const beamGeometry = new THREE.BoxGeometry(LIBRARY_WIDTH, 0.5, 1);
                const beam = new THREE.Mesh(beamGeometry, beamMaterial);
                beam.position.set(0, LIBRARY_HEIGHT - 0.25, i * 12);
                beam.castShadow = true;
                scene.add(beam);
            }

            for (let i = -2; i <= 2; i++) {
                const beamGeometry = new THREE.BoxGeometry(1, 0.5, LIBRARY_DEPTH);
                const beam = new THREE.Mesh(beamGeometry, beamMaterial);
                beam.position.set(i * 12, LIBRARY_HEIGHT - 0.25, 0);
                beam.castShadow = true;
                scene.add(beam);
            }

            const medallionGeometry = new THREE.CylinderGeometry(3, 3, 0.3, 32);
            const medallionMaterial = new THREE.MeshStandardMaterial({ color: 0xd4af37 });
            const medallion = new THREE.Mesh(medallionGeometry, medallionMaterial);
            medallion.position.set(0, LIBRARY_HEIGHT - 0.4, 0);
            medallion.castShadow = true;
            scene.add(medallion);
        }

        function createBookShelves() {
            let bookIndex = 0;
            const totalBookcasesNeeded = Math.ceil(books.length / BOOKS_PER_BOOKCASE);

            const bookcaseLayout = [
                { pos: new THREE.Vector3(-(BOOKCASE_WIDTH + BOOKCASE_SPACING), 0, -18), rotY: 0 },
                { pos: new THREE.Vector3(0, 0, -18), rotY: 0 },
                { pos: new THREE.Vector3((BOOKCASE_WIDTH + BOOKCASE_SPACING), 0, -18), rotY: 0 }
            ];
            
            for (let i = 0; i < totalBookcasesNeeded && i < bookcaseLayout.length; i++) {
                const slot = bookcaseLayout[i];
                createSingleBookcase(slot.pos, slot.rotY, bookIndex);
                bookIndex += Math.min(BOOKS_PER_BOOKCASE, books.length - bookIndex);
            }
        }

        function createSingleBookcase(position, rotation, startBookIndex) {
            const bookcaseGroup = new THREE.Group();
            bookcaseGroup.position.copy(position);
            bookcaseGroup.rotation.y = rotation;
            
            const shelfMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.7,
                metalness: 0.1
            });
            const supportMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x5d4d37,
                roughness: 0.8,
                metalness: 0.1
            });
            
            const supportGeometry = new THREE.BoxGeometry(SUPPORT_WIDTH, BOOKCASE_HEIGHT, SHELF_DEPTH);
            const leftSupport = new THREE.Mesh(supportGeometry, supportMaterial);
            leftSupport.position.set(-BOOKCASE_WIDTH / 2 + SUPPORT_WIDTH / 2, BOOKCASE_HEIGHT / 2, 0);
            leftSupport.castShadow = true;
            bookcaseGroup.add(leftSupport);
            
            const rightSupport = new THREE.Mesh(supportGeometry, supportMaterial);
            rightSupport.position.set(BOOKCASE_WIDTH / 2 - SUPPORT_WIDTH / 2, BOOKCASE_HEIGHT / 2, 0);
            rightSupport.castShadow = true;
            bookcaseGroup.add(rightSupport);
            
            for (let shelfLevel = 0; shelfLevel < SHELVES_PER_BOOKCASE; shelfLevel++) {
                const yPosition = SHELF_BASE_Y + shelfLevel * SHELF_SPACING_Y;
                const shelfGeometry = new THREE.BoxGeometry(BOOKCASE_WIDTH, SHELF_THICKNESS, SHELF_DEPTH);
                const shelf = new THREE.Mesh(shelfGeometry, shelfMaterial);
                shelf.position.set(0, yPosition, 0);
                shelf.castShadow = true;
                bookcaseGroup.add(shelf);
                
                for (let bookPos = 0; bookPos < BOOKS_PER_SHELF; bookPos++) {
                    const currentBookIndex = startBookIndex + shelfLevel * BOOKS_PER_SHELF + bookPos;
                    if (currentBookIndex >= books.length) break;
                    const book = books[currentBookIndex];
                    const bookX = -BOOKCASE_WIDTH / 2 + BOOK_SPACING_X + (bookPos * BOOK_SPACING_X);
                    const bookY = yPosition + (BOOK_HEIGHT / 2) + (SHELF_THICKNESS / 2);
                    const bookZ = 0;
                    createBookCover(book, bookX, bookY, bookZ, bookcaseGroup);
                }
            }
            
            scene.add(bookcaseGroup);
            collisionMeshes.push(bookcaseGroup);
        }

        function createWaterFeatures() {
            createFountain(0, 0, 0);
            createWaterfall(-25, 0, -25);
        }

        function createFountain(x, y, z) {
            const fountainGroup = new THREE.Group();
            
            const stoneMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x696969,
                roughness: 0.8,
                metalness: 0.1
            });
            const waterMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x4169e1,
                roughness: 0.1,
                metalness: 0.1,
                transparent: true,
                opacity: 0.7
            });

            const baseGeometry = new THREE.CylinderGeometry(4, 4, 0.5, 32);
            const base = new THREE.Mesh(baseGeometry, stoneMaterial);
            base.position.y = 0.25;
            base.castShadow = true;
            fountainGroup.add(base);

            const poolGeometry = new THREE.CylinderGeometry(3.8, 3.8, 0.3, 32);
            const pool = new THREE.Mesh(poolGeometry, waterMaterial);
            pool.position.y = 0.45;
            fountainGroup.add(pool);

            const columnGeometry = new THREE.CylinderGeometry(0.5, 0.5, 3, 16);
            const column = new THREE.Mesh(columnGeometry, stoneMaterial);
            column.position.y = 2;
            column.castShadow = true;
            fountainGroup.add(column);

            const topGeometry = new THREE.SphereGeometry(0.8, 16, 16);
            const top = new THREE.Mesh(topGeometry, stoneMaterial);
            top.position.y = 3.8;
            top.castShadow = true;
            fountainGroup.add(top);

            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const jetGeometry = new THREE.CylinderGeometry(0.02, 0.02, 2, 8);
                const jet = new THREE.Mesh(jetGeometry, waterMaterial);
                jet.position.set(
                    Math.cos(angle) * 0.3,
                    2.5,
                    Math.sin(angle) * 0.3
                );
                fountainGroup.add(jet);
            }

            const fountainLight = new THREE.PointLight(0x87ceeb, 1.5, 15);
            fountainLight.position.set(0, 2, 0);
            fountainGroup.add(fountainLight);

            fountainGroup.position.set(x, y, z);
            scene.add(fountainGroup);
            collisionMeshes.push(fountainGroup);
        }

        function createWaterfall(x, y, z) {
            const waterfallGroup = new THREE.Group();
            
            const rockMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x654321,
                roughness: 0.9,
                metalness: 0.1
            });
            const waterMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x4169e1,
                roughness: 0.1,
                metalness: 0.1,
                transparent: true,
                opacity: 0.6
            });

            const rockGeometry = new THREE.BoxGeometry(8, 6, 4);
            const rock = new THREE.Mesh(rockGeometry, rockMaterial);
            rock.position.y = 3;
            rock.castShadow = true;
            waterfallGroup.add(rock);

            const cascadeGeometry = new THREE.PlaneGeometry(2, 6);
            const cascade = new THREE.Mesh(cascadeGeometry, waterMaterial);
            cascade.position.set(0, 3, 2.1);
            waterfallGroup.add(cascade);

            const poolGeometry = new THREE.CylinderGeometry(3, 3, 0.5, 32);
            const pool = new THREE.Mesh(poolGeometry, waterMaterial);
            pool.position.y = 0.25;
            waterfallGroup.add(pool);

            for (let i = 0; i < 20; i++) {
                const mistGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const mistMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.3
                });
                const mist = new THREE.Mesh(mistGeometry, mistMaterial);
                mist.position.set(
                    (Math.random() - 0.5) * 4,
                    Math.random() * 4 + 1,
                    2 + (Math.random() - 0.5) * 2
                );
                waterfallGroup.add(mist);
            }

            waterfallGroup.position.set(x, y, z);
            scene.add(waterfallGroup);
            collisionMeshes.push(waterfallGroup);
        }

        function createLuxuryFurniture() {
            const mahoganyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x654321,
                roughness: 0.3,
                metalness: 0.1
            });
            const velvetMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8b0000,
                roughness: 0.9,
                metalness: 0.0
            });

            // Luxury seating areas
            createLuxurySeatingArea(-15, 0, 10, mahoganyMaterial, velvetMaterial);
            createLuxurySeatingArea(15, 0, 10, mahoganyMaterial, velvetMaterial);

            // Crystal chandeliers
            createChandelier(0, 9, 0);
            createChandelier(-20, 9, -10);
            createChandelier(20, 9, -10);
        }

        function createLuxurySeatingArea(x, y, z, frameMaterial, cushionMaterial) {
            const sofaGroup = new THREE.Group();
            
            const frameGeometry = new THREE.BoxGeometry(4, 0.5, 2);
            const frame = new THREE.Mesh(frameGeometry, frameMaterial);
            frame.position.y = 0.25;
            frame.castShadow = true;
            sofaGroup.add(frame);

            const cushionGeometry = new THREE.BoxGeometry(3.8, 0.6, 1.8);
            const cushion = new THREE.Mesh(cushionGeometry, cushionMaterial);
            cushion.position.y = 0.8;
            cushion.castShadow = true;
            sofaGroup.add(cushion);

            const backGeometry = new THREE.BoxGeometry(4, 1.5, 0.3);
            const back = new THREE.Mesh(backGeometry, cushionMaterial);
            back.position.set(0, 1.25, -0.85);
            back.castShadow = true;
            sofaGroup.add(back);

            sofaGroup.position.set(x, y, z);
            scene.add(sofaGroup);
            collisionMeshes.push(sofaGroup);

            const tableGroup = new THREE.Group();
            const tableTopGeometry = new THREE.CylinderGeometry(1.5, 1.5, 0.1, 32);
            const tableTop = new THREE.Mesh(tableTopGeometry, frameMaterial);
            tableTop.position.y = 0.6;
            tableTop.castShadow = true;
            tableGroup.add(tableTop);

            const tableBaseGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.6, 16);
            const tableBase = new THREE.Mesh(tableBaseGeometry, frameMaterial);
            tableBase.position.y = 0.3;
            tableBase.castShadow = true;
            tableGroup.add(tableBase);

            tableGroup.position.set(x, y, z + 3);
            scene.add(tableGroup);
            collisionMeshes.push(tableGroup);
        }

        function createChandelier(x, y, z) {
            const chandelierGroup = new THREE.Group();
            
            const goldMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffd700,
                roughness: 0.2,
                metalness: 0.8
            });
            const crystalMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffffff,
                roughness: 0.1,
                metalness: 0.1,
                transparent: true,
                opacity: 0.8
            });

            const chainGeometry = new THREE.CylinderGeometry(0.05, 0.05, 2, 8);
            const chain = new THREE.Mesh(chainGeometry, goldMaterial);
            chain.position.y = 1;
            chandelierGroup.add(chain);

            const frameGeometry = new THREE.TorusGeometry(1.5, 0.1, 8, 32);
            const frame = new THREE.Mesh(frameGeometry, goldMaterial);
            chandelierGroup.add(frame);

            for (let i = 0; i < 16; i++) {
                const angle = (i / 16) * Math.PI * 2;
                const crystalGeometry = new THREE.ConeGeometry(0.05, 0.3, 6);
                const crystal = new THREE.Mesh(crystalGeometry, crystalMaterial);
                crystal.position.set(
                    Math.cos(angle) * 1.5,
                    -0.3,
                    Math.sin(angle) * 1.5
                );
                chandelierGroup.add(crystal);
            }

            const light = new THREE.PointLight(0xffffff, 1.0, 20);
            light.position.set(0, 0, 0);
            light.castShadow = true;
            chandelierGroup.add(light);

            chandelierGroup.position.set(x, y, z);
            scene.add(chandelierGroup);
        }

        function createBookCover(book, x, y, z, parentGroup) {
            const bookGeometry = new THREE.BoxGeometry(BOOK_WIDTH, BOOK_HEIGHT, BOOK_THICKNESS);
            const loader = new THREE.TextureLoader();
            const defaultMaterial = new THREE.MeshPhongMaterial({ color: 0x5d4d37 });
            const bookMesh = new THREE.Mesh(bookGeometry, defaultMaterial);
            bookMesh.position.set(x, y, z);
            bookMesh.castShadow = true;
            bookMesh.userData = { book };
            
            loader.load(book.customCoverUrl, (texture) => {
                texture.encoding = THREE.sRGBEncoding;
                texture.flipY = true;
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                
                const materials = [
                    new THREE.MeshLambertMaterial({ color: 0x5d4d37 }),
                    new THREE.MeshLambertMaterial({ color: 0x5d4d37 }),
                    new THREE.MeshLambertMaterial({ color: 0x5d4d37 }),
                    new THREE.MeshLambertMaterial({ color: 0x5d4d37 }),
                    new THREE.MeshLambertMaterial({ map: texture }),
                    new THREE.MeshLambertMaterial({ color: 0x5d4d37 })
                ];
                bookMesh.material = materials;
            }, undefined, () => createFallbackCover(bookMesh, book));
            
            parentGroup.add(bookMesh);
            bookMeshes.push(bookMesh);
        }

        function createFallbackCover(bookMesh, book) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 768;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#8b7355');
            gradient.addColorStop(1, '#5d4e37');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = '#d4af37';
            ctx.lineWidth = 6;
            ctx.strokeRect(15, 15, canvas.width - 30, canvas.height - 30);
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            const title = book.title;
            const maxWidth = canvas.width - 60;
            const lineHeight = 30;
            const words = title.split(' ');
            let line = '';
            let y = 90;
            for (let n = 0; n < words.length; n++) {
                const testLine = line + words[n] + ' ';
                const testWidth = ctx.measureText(testLine).width;
                if (testWidth > maxWidth && n > 0) {
                    ctx.fillText(line, canvas.width / 2, y);
                    line = words[n] + ' ';
                    y += lineHeight;
                } else {
                    line = testLine;
                }
            }
            ctx.fillText(line, canvas.width / 2, y);
            ctx.font = '21px Arial';
            ctx.fillStyle = '#e0e0e0';
            ctx.fillText(book.author, canvas.width / 2, canvas.height - 90);
            const texture = new THREE.CanvasTexture(canvas);
            const materials = [
                new THREE.MeshPhongMaterial({ color: 0x5d4d37 }),
                new THREE.MeshPhongMaterial({ color: 0x5d4d37 }),
                new THREE.MeshPhongMaterial({ color: 0x5d4d37 }),
                new THREE.MeshPhongMaterial({ color: 0x5d4d37 }),
                new THREE.MeshBasicMaterial({ map: texture }),
                new THREE.MeshPhongMaterial({ color: 0x5d4d37 })
            ];
            bookMesh.material = materials;
        }

        // =============================================================================
        // INTERACTION FUNCTIONS
        // =============================================================================
        function setupMouseInteraction() {
            renderer.domElement.addEventListener('click', onMouseClick, false);
        }

        function onMouseClick(event) {
            if (document.pointerLockElement === renderer.domElement) return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(bookMeshes, true);

            if (intersects.length > 0) {
                const clickedBook = intersects[0].object.userData.book;
                if (clickedBook) {
                    showBookDetails(clickedBook);
                }
            }
        }

        function showBookDetails(book) {
            document.getElementById('modalTitle').textContent = book.title;
            document.getElementById('modalAuthor').textContent = book.author;
            document.getElementById('modalCategory').textContent = book.category;
            document.getElementById('modalStatus').textContent = book.status;
            document.getElementById('modalOwnership').textContent = book.ownership;
            document.getElementById('modalDate').textContent = book.dateCompleted || 'Not completed';
            document.getElementById('modalSummary').textContent = book.summary;
            document.getElementById('modalBookCover').src = book.customCoverUrl;
            modal.style.display = 'block';
        }

        function setupVR() {
            vrButton = document.getElementById('vrButton');
            if (!vrButton) return;

            if ('xr' in navigator) {
                navigator.xr.isSessionSupported('immersive-vr').then((supported) => {
                    if (supported) {
                        vrButton.addEventListener('click', () => {
                            if (isVREnabled) {
                                renderer.xr.getSession().end();
                            } else {
                                navigator.xr.requestSession('immersive-vr', { requiredFeatures: ['local-floor'] })
                                    .then((session) => {
                                        renderer.xr.setSession(session);
                                        isVREnabled = true;
                                        vrButton.textContent = 'Exit VR';
                                        session.addEventListener('end', () => {
                                            isVREnabled = false;
                                            vrButton.textContent = 'Enter VR';
                                        });
                                    }).catch((error) => console.error('VR session failed:', error));
                            }
                        });
                    } else {
                        vrButton.textContent = 'VR Not Supported';
                        vrButton.disabled = true;
                    }
                }).catch((error) => {
                    vrButton.textContent = 'VR Error';
                    vrButton.disabled = true;
                });
            } else {
                vrButton.textContent = 'VR Not Supported';
                vrButton.disabled = true;
            }
        }

        function setupNavigationTool() {
            const navButtons = {
                navUp: { action: 'moveVertical', value: 1 },
                navDown: { action: 'moveVertical', value: -1 },
                navLeft: { action: 'moveStrafe', value: -1 },
                navRight: { action: 'moveStrafe', value: 1 },
                navForward: { action: 'moveForward', value: -1 },
                navBackward: { action: 'moveForward', value: 1 },
                navRotateLeft: { action: 'lookHorizontal', value: -1 },
                navRotateRight: { action: 'lookHorizontal', value: 1 }
            };

            Object.keys(navButtons).forEach(buttonId => {
                const button = document.getElementById(buttonId);
                if (!button) return;

                const config = navButtons[buttonId];
                let isPressed = false;

                const startAction = (e) => {
                    if (e) e.preventDefault();
                    if (isPressed) return;
                    isPressed = true;
                    inputController.setButtonAction(config.action, config.value);
                    button.classList.add('active');
                };

                const stopAction = (e) => {
                    if (e) e.preventDefault();
                    if (!isPressed) return;
                    isPressed = false;
                    inputController.setButtonAction(config.action, 0);
                    button.classList.remove('active');
                };

                button.addEventListener('mousedown', startAction);
                button.addEventListener('mouseup', stopAction);
                button.addEventListener('mouseleave', stopAction);
                button.addEventListener('touchstart', startAction, { passive: false });
                button.addEventListener('touchend', stopAction, { passive: false });
                button.addEventListener('touchcancel', stopAction, { passive: false });
                button.addEventListener('contextmenu', (e) => e.preventDefault());
            });
        }

        function animate() {
            renderer.setAnimationLoop(() => {
                const delta = clock.getDelta();

                inputController.update();

                if (inputController.actions.reset) {
                    playerController.resetView();
                    inputController.actions.reset = false;
                }

                playerController.update(delta, inputController.actions);
                animateWaterEffects();
                renderer.render(scene, camera);
            });
        }

        function animateWaterEffects() {
            const time = Date.now() * 0.001;
            
            scene.traverse((child) => {
                if (child.isMesh && child.material && child.material.color && 
                    child.material.color.getHex() === 0x4169e1 && 
                    child.geometry && child.geometry.type === 'CylinderGeometry') {
                    child.position.y += Math.sin(time * 2 + child.position.x) * 0.02;
                }
                
                if (child.isMesh && child.material && child.material.color &&
                    child.material.color.getHex() === 0xffffff && child.material.transparent) {
                    child.position.y += Math.sin(time * 3 + child.position.x * 10) * 0.01;
                    child.material.opacity = 0.2 + Math.sin(time * 4 + child.position.z * 5) * 0.1;
                }
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // =============================================================================
        // INITIALIZATION
        // =============================================================================
        function init() {
            modal = document.getElementById('bookModal');
            closeBtn = document.querySelector('.close');

            if (!modal || !closeBtn) {
                console.error('Required DOM elements not found');
                return;
            }

            closeBtn.onclick = () => { modal.style.display = 'none'; };
            window.onclick = (event) => { if (event.target == modal) modal.style.display = 'none'; };

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 3.5, 25);
            camera.userData.initialPosition = camera.position.clone();
            camera.userData.initialRotation = camera.rotation.clone();

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.xr.enabled = true;
            renderer.outputEncoding = THREE.sRGBEncoding;
            document.body.appendChild(renderer.domElement);
            
            inputController = new InputController();
            inputController.connect();
            playerController = new PlayerController(camera, renderer.domElement);
            
            createLighting();
            createMansionEnvironment();
            createBookShelves();
            createLuxuryFurniture();
            createWaterFeatures();
            setupMouseInteraction();
            setupVR();

            document.getElementById('bookCount').textContent = books.length;
            setupNavigationTool();
            window.addEventListener('resize', onWindowResize);
            animate();
        }

        // =============================================================================
        // START APPLICATION
        // =============================================================================
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    </script>
</body>
</html>
